{"./":{"url":"./","title":"苍穹战队秋招电控培训","summary":"RoboMaster苍穹战队电控培训电子书","keywords":"","body":"苍穹战队秋招电控培训 版本控制 V1.0-添加基础导论和一些相关资料 V1.1-添加新手向学习路线，添加RM论坛资源 V1.2-增加嵌入式导论和初识GPIO V1.3-增加第一次培训内容 Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-12 12:03:41 "},"0.-dian-kong-dao-lun-ji-di-ling-ke/0.1-dian-kong-dao-lun.html":{"url":"0.-dian-kong-dao-lun-ji-di-ling-ke/0.1-dian-kong-dao-lun.html","title":"0.1电控导论","summary":"***简单介绍电控组的工作***","keywords":"","body":"0.1电控导论 0.1.1电控组介绍 组如其名，我们的工作主要内容就是“电”和“控制”。“电”是指电控组队员要具有独立布置机器人上电线的布局，这需要我们拥有基本的焊接，连线的技能；“控制”是指队员具有独立编写代码用于驱动机器人上各种外设的能力。 (由于往年都会有同学区分不了电控组和视觉组，在这里注重标注一下两组的不同) 项目 电控 视觉（算法组） 专业知识 嵌入式编程，机器人学，自动控制原理…… 计算机视觉，深度学习，ROS…… 编程语言 C语言为主 C++,Python为主 在开发流程中的位置 当机械组和硬件组完成工作后，接下来就是电控来进行机器人外设的驱动 当电控完成基本驱动后，有视觉部署自己的算法，是机器人更加智能（位于开发链的最后一层） 以上内容只是为了帮助各位选取自己更感兴趣的组别加入，为了减少或者杜绝培训后才发现自己想加入的是另外一个组 0.1.2加入电控组你可以收获什么 焊接和布线 自己动手焊接线材，基础电路知识 代码编写能力 C/C++程序设计（基础） 单片机： GPIO输入输出、EXTI中断、TIM中断、PWM波形输出、UART通信协议、ADC等基础内容 ；FreeRTOS、CAN通信、USB虚拟串口 0.1.3学习路线（摘取自中科大开源电控培训（仅供参考和了解）） PS：这个是学习路线图，包括未入队阶段和入队阶段，在此列出只是给各位一个大概的学习思路，不至于特别迷茫（我们的培训只会包含一些基础的课程） 新手学习线路图 0.1.4电控精神 这个是此文档最重要的内容！！！ 0.1.5另外说明 由于本文档使用Gitbook编写，并且为了战队复用，会将此电子书发布到GitHub上托管。所以请各位同学提前学习有关Git的相关知识（我会在后续开一章详细介绍）。 同时为了同学方便查阅，此电子书会本地上传到QQ电控群群文件中。 由于笔者能力有限，有错误和不准确的地方请指出！！！ 再次感谢中科大RoboWalker战队开源的电控教程！！！ Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-09-18 20:16:59 "},"0.-dian-kong-dao-lun-ji-di-ling-ke/0.2-dian-kong-zi-liao-he-xiang-guan-lian-jie.html":{"url":"0.-dian-kong-dao-lun-ji-di-ling-ke/0.2-dian-kong-zi-liao-he-xiang-guan-lian-jie.html","title":"0.2电控资料和相关链接","keywords":"","body":"0.2电控资料和相关链接 C语言方面 菜鸟教程（电子书）：https://www.runoob.com/cprogramming/c-tutorial.html 浙江大学翁恺（视频）：https://www.bilibili.com/video/BV1dr4y1n7vA/?spm_id_from=333.337.search-card.all.click 嵌入式方面 第一关：软件下载：keil,CubeMax 下载参考文档：2024最新Keilv5下载安装注册及添加ARM5编译器_keil下载-CSDN博客 下载参考视频：[2-1] 软件安装_哔哩哔哩_bilibili 电子扫盲：[喂饭级]一期献给准大学生们的电脑入门喂饭级教程_哔哩哔哩_bilibili 注：配置环境是学习嵌入式的第一关，遇到问题多从网上寻找答案，推荐CSDN,b站 第二关：选择合适的学习开发工具 基础硬件：入门推荐STM32F1系列芯片，这里推荐江科大售卖的套件，够后续持续学 习，也可以从闲鱼找便宜的套件，内包含基础硬件：F103C8T6，面包板，杜邦线，OLED， STLINK 等其余模块传感器。 第三关：学习单片机 推荐b站视频和CSND文档: 1.江科大：STM32入门教程-2023版 细致讲解 中文字幕_哔哩哔哩_bilibili 优点：对于32底层原 理讲的细致，一遍不理解的应当反复观看，更偏重原理 缺点：该视频使用的标准库编写程 序，标准库编写需要自己配置底层，过程显得繁琐，我们要求使用HAL库，借助CubeMax 一键生成底层代码。 2.Keysking: 【STM32入门教程】应该是全B站最好的STM32教程了！！_哔哩哔哩_bilibili优点：使用CubeMAx 编写讲解代码,更偏重应用 缺点：使用CubeIDE编写程序，而我们要求的是使用Keil，该视 频主要学习如何使用CubeMax配置相关底层参数并一键生成，模块介绍不多。 3.Z小旋：【STM32】HAL库 STM32CubeMX系列学习教程_stm32hal库学习路线-CSDN博客优点：文档教学，适合喜欢看文档的，使用CubeMAx 编写代码,理论应用相当 缺点：使用STM32F4板子，而我们一般使用STM32F1但影响不大，可以对照参考学习。 其他资料 rm论坛 里面有很多其他学校或者战队的开源，都是宝贝和学习资源；对于新手来说，里面有”新手任务“，很适合练手，同时也可以再多了解一些rm的信息） https://bbs.robomaster.com/portal.phprm 华南虎搜索引擎（https://search.scutbot.cn/） 适合联手的小项目： https://bbs.robomaster.com/wiki/1350236/88130\\ 后续会不定期更新…… Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-09-01 00:41:13 "},"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.1-qian-ru-shi-wu-liao-gou-mai-ji-huan-jing-xiang-xi-pei-zhi-keil5.html":{"url":"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.1-qian-ru-shi-wu-liao-gou-mai-ji-huan-jing-xiang-xi-pei-zhi-keil5.html","title":"1.1 嵌入式物料购买及环境详细配置（Keil5）","summary":"内容包括软件环境安装及硬件物材购买","keywords":"","body":"1.1 嵌入式物料购买及环境详细配置（Keil5） 硬件物材购买 培训单片机最小系统板为STM32F103C8T6（注意购买的芯片是否为盗版）：建议嘉立创商城购买 (搜索地阔星开发板）（https://wiki.lckfb.com/zh-hans/dkx-stm32f103c8t6/beginner/)； PS：嘉立创开发手册中是标准库，不是我们使用的HAL库 面包板(用于电气连接)，杜邦线（公对公，公对母，母对母）每种大约40根左右就很充足， ST-link（程序下载器） 所需外设： 动力系统：TT电机和电机驱动模块TB6612FNG（可以先随便买一个玩，要用在车上的话需要和机械队友讨论）;舵机模块sg90; 通信控制系统：USB转TTL（串口模块）；蓝牙模块或者2.4G无线通信（取决于小车的控制通信方式）； 电源系统：电池12v;稳压模块（12V转5V；12V转3.3V都要具备） Keil5 环境配置 学习嵌入式主要需要用到Keil5和STM32CUBEMX 一. 安装Keil5： 1. 下载群文件《新人电控一整套》 2. 解压该文件：解压密码：fanbaomiaomiao 3. 安装MDK：点击运行MDK535.EXE文件 4. 在弹出的界面，点击NEXT 5. 勾选I agree，点击Next 6. 记住界面弹出的默认安装的路径，点击Next。在这里有两个注意事项：1.安装路径里面不要有中文！2.不要安装在C:\\Program Files这个文件夹里！ 补充事项：如果想更改安装位置，点击右边的[Browse]，更改的时候也要记住更改的位置，Core和Pack都要记住。 7. 填写用户信息，可以随便填写；点击Next 8. 等待keil5的安装 9. 安装完成后，在弹出的界面中点击Finish 10. 关闭弹出来的Pack Installer窗口：关掉它 11. 激活MDK：在桌面上右击keil图标，在弹出的选项卡中选择以管理员身份运行（很重要很重要！！！） 12. 点击File，选择License Management 13. 复制CID 14. 在安装文件中点击keygen.exe文件（运行前一定静音！！！！！，喜欢刺激的同学可以把声音调到最大） 15. 粘贴复制过的CID，选择Target为ARM，点击Generate，生成激活码 16. 复制生成的激活码，粘贴在New License ID Code处，点击Add LIC，即可成功激活mdk，显示mdk的使用期限 17. 在安装文件中点击Keil.STM32F1xx_DFP.1.1.0.pack 18. 点击Next 进行安装，安装完成后，点击Finish 19. 到此keil5就成功安装并激活了！ 二、安装STM32CUBEMX 1.首先需要安装java环境，运行这个jre开头的文件，完成安装即可，安装路径不要有中文 2.安装完Java后，运行这个Setup开头的文件，完成安装即可，安装路径不要有中文 3.安装这一步时直接默认即可。 4.java和cubemx的具体安装过程可以参考：STM32CubeMX 下载及安装教程_Brendon_Tan的博客-CSDN博客 第三部分： 欧克，到这里Keil5和STM32CUBEMX就全部安装完了！ 驱动安装 设备是通过不同的通信协议来与电脑进行连接，这就要求我们安装驱动程序 有时在设备管理器里查找不到自己连接的器件，这时就要去寻找自己是否安装对应的驱动程序 一般的驱动包含： ST-LINK下载器的驱动程序 USB装TTL串口模块驱动 ...... Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-09-27 21:25:21 "},"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.2-chu-shi-dan-pian-ji.html":{"url":"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.2-chu-shi-dan-pian-ji.html","title":"1.2 初识单片机","summary":"对单片机的简单介绍","keywords":"","body":"1.2 初识单片机 STM32系列单片机 一张图读懂单片机命名，本次培训使用的是最基础的STM32F103C8T6 拿到单片机后，最重要的是去搜索其==原理图==和所拥有的外设资源 https://blog.csdn.net/fantastic_sky/article/details/110229474 对于单片机的详细原理构成这里不做详细讲解，初学者只需知道单片机包含的外设资源就可（GPIO,USART,ADC...） 单片机的简单构成（这部分看不懂也没事） 核心处理器（CPU） 采用32位数据总线和地址总线 常见架构如ARM Cortex-M系列、RISC-V等 具有更强大的运算能力和指令集 存储器 Flash存储器：用于存储程序代码，掉电不会丢失 SRAM：用于存储运行时数据，掉电时全部丢失 ROM：存储引导程序和基本配置 时钟系统 主时钟（通常为外部晶振）单片机的心跳，每一次跳动都代表数据更新（新陈代谢）。 外设接口 GPIO（通用输入输出口） UART/USART（串口通信） SPI（串行外设接口） I2C（双线串行接口） ADC（模数转换器） DAC（数模转换器） USB接口 CAN总线接口等 中断控制器 支持多级中断优先级 向量中断控制 快速中断响应 我们如何通过代码控制单片机 程序员通过C语言等高级语言，编写操作特定内存地址（这些地址就是寄存器的地址）的指令。这些指令被编译成机器码后，由单片机的CPU执行，从而改变寄存器中的值（0或1）。由于寄存器的每一位都与硬件功能（如引脚电平、定时器开关等）物理上关联，因此改变寄存器的值，就直接控制了单片机的硬件行为。 为了方便，芯片厂商通常会提供一个头文件（Header File），里面已经帮你把所有难记的寄存器地址都用好记的名字（如 GPIOA_ODR）定义好了。你只需要引入这个头文件，就可以直接使用这些名字，而不用去记那些复杂的十六进制地址了。这让编程变得更加简单和直观。 这个就是我们常说的库函数 库函数 常见的库函数包含标准库和HAL库（The hardware abstraction layer） 标准库 ST公司就为每款芯片都编写了一份库文件，也就是工程文件里stm32F1xx.....之类的。在这些.c .h文件中，包括一些常用量的宏定义，把一些外设也通过结构体变量封装起来，如GPIO口时钟等。所以我们只需要配置结构体变量成员就可以修改外设的配置寄存器，从而选择不同的功能。是学习STM32接触最多的一种开发方式，我们这次培训并不使用这类库，我也就不多阐述了。 HAL库 HAL库是ST公司目前主力推的开发方式，全称就是Hardware Abstraction Layer（抽象印象层）。库如其名，很抽象，一眼看上去不太容易知道他的作用是什么。它的出现比标准库要晚，但其实和标准库一样，都是为了节省程序开发的时期，而且HAL库尤其的有效，如果说标准库把实现功能需要配置的寄存器集成了，那么HAL库的一些函数甚至可以做到某些特定功能的集成。也就是说，同样的功能，标准库可能要用几句话，HAL库只需用一句话就够了。并且HAL库也很好的解决了程序移植的问题，不同型号的stm32芯片它的标准库是不一样的，例如在F4上开发的程序移植到F3上是不能通用的，而使用HAL库，只要使用的是相通的外设，程序基本可以完全复制粘贴，注意是相通外设，意思也就是不能无中生有，例如F7比F3要多几个定时器，不能明明没有这个定时器却非要配置，但其实这种情况不多，绝大多数都可以直接复制粘贴。而且使用ST公司研发的STMcube软件，可以通过图形化的配置功能，直接生成整个使用HAL库的工程文件，可以说是方便至极，但是方便的同时也造成了它执行效率的低下，在各种论坛帖子真的是被吐槽的数不胜数。 而我们战队主要使用的是HAL库，主要看重其配置方便，而且RM中大多数电控资源也都是HAL库。 工作流程 Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-12 11:58:52 "},"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.3- 使用GPIO点亮板载LED.html":{"url":"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.3- 使用GPIO点亮板载LED.html","title":"1.3 使用GPIO点亮板载LED","keywords":"","body":"使用GPIO点亮板载LED 认识时钟 时钟，是STM32单片机以及各种设备的心跳， 时钟信号是一种高低电平交替变化的脉冲信号。每一次变化（比如从低到高）都代表单片机完成了一个最基本的动作（比如处理一次指令、移动一次数据）。 时钟频率（单位是Hz）决定了单片机运行的快慢。比如8MHz，意思是每秒有800万次“鼓点”。频率越高，单片机工作越快。 单片机要按照一定的顺序来完成各种任务，这就需要有一个统一的“节拍”。时钟让所有部件步调一致，不会乱套。 有低速高速两种（High Speed，HS与Low Speed，LS），低速用于实时时钟（Real Time Clock，RTC）等。 高速用于定时器、UART、ADC等多种外设。 时钟与外设使用 总线连接，外设总线：包括APB1和APB2。 在Cubemx中可以清楚看到时钟总线分配给各种外设。 认识GPIO GPIO综述 GPIO（General Purpose Input/Output，通用输入输出口）可以类比为人体的“手和脚”等，可以与外界进行交互。 从上图可以看到此款单片机的四种GPIO（PA,PB,PC,PD）都是挂载在APB2时钟上的。在cubemx中，我们可以配置GPIO的工作模式以让其发挥我们想要的功能。 GPIO的八种工作模式 输出模式VS输入模式 ”写“可以理解为将此引脚置为高电平；”读“可以理解为感应此引脚的电平。 推挽模式（Push-Pull）VS开漏模式（Open-Drain） 推挽模式 推挽模式下，GPIO端口内部有两个晶体管，一个连接电源，一个连接地。 当输出高电平时，上方晶体管导通，端口直接输出电源电压（如3.3V或5V）。 当输出低电平时，下方晶体管导通，端口直接输出地（0V）。 能够主动输出高、低电平，驱动能力强，适合直接驱动LED、继电器等负载。 ==宁折不弯，推挽高低电平相遇会烧坏== 开漏模式 开漏模式下，GPIO端口内部只有一个下拉晶体管，连接地。 当输出低电平时，晶体管导通，端口接地（0V）。 当输出高电平时，晶体管关闭，端口处于悬空（不输出电压），需要外部上拉电阻将端口拉到高电平。 ==不能主动输出高电平，只能“拉低”或“释放”。== 复用VS通用 从上图可以看出通用输出是由CPU直接控制引脚；复用输出用于外设对引脚有特殊要求（绑定了特定MCU内功能输出），其实就是用作其他外设的专用引脚。 输入的四种模式 输入上拉和下拉就是默认状态下该引脚的电平为高电平3.3V，0V。 浮空输入模式下，电平的状态飘忽不定，测量时可能出现0~3.3V之间的任意电压值。 输入模拟与前三种输入模式不同，它是唯一可以读取模拟量（即连续时间连续值），其他都是数字信号输入。 点亮单片机板载LED 首先当我们想要完成某一个功能时，一定要有理论知识去支撑我们完成这个功能，那么我们需要知道点亮LED灯的原理，知道原理后我们才能有根据的配置32单片机外设和编写代码。 LED原理 LED在这里是指发光二极管，二极管导通的条件是给其施加一个正向电压就行。 如上图所示，我们需要配置好一个电子回路。该庆幸的是板载最小系统板在设计的时候就已经有帮我们设计好了的电路。 如上图，D1在系统板上电是就会一直处于导通状态，而D2的状态完全处于PC13，所以接下我们要做的的就是控制PC13引脚进而控制D2的状态。 CubeMX的工程配置 STM32F103C8T6基础开发教程（HAL库）—点亮第一颗LED灯_stm32f103c8t6 教程-CSDN博客 具体操作可以看这篇博客，操作基本都有讲解。 ==PS：自己的LED引脚可能与这篇文章作者不同，请根据实际情况来操作== ==•Keil中，取消编译优化，打开C99，以及—cpp11== ==•Reset and run== 在这里点一下最重要，也是基本每次配置工程都会用到的两步 选择调试模式，如果不选你无法使用stlink这类下载工具； 选择时钟源 代码编写 while (1) { /* USER CODE END WHILE */ HAL_GPIO_WritePin(LED_GPIO_Port,LED_Pin,GPIO_PIN_SET);//用户编写的只有这个一段代码实现灯常亮 // GPIOx：对应的 GPIO 端口。例如 LED_GPIO_Port 可能是 GPIOA、GPIOB 等。 // GPIO_Pin：要操作的引脚。例如 LED_Pin，一般是类似 GPIO_PIN_1、GPIO_PIN_5 这样的宏。 // PinState：设置引脚的电平状态。可以是： // GPIO_PIN_SET：将引脚设置为高电平（输出为 1） // GPIO_PIN_RESET：将引脚设置为低电平（输出为 0） HAL_Delay(1000);//延时函数，单位为ms,这里起到的作用是使led灯一秒改变一次状态; /* USER CODE BEGIN 3 */ } Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-11 23:09:35 "},"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.4-中断.html":{"url":"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.4-中断.html","title":"1.4 中断","keywords":"","body":"外部中断EXTI 单片机执行原理（暂时看不懂没事） 从抽象上看，==处理器系统==是一台能运算数据、操控内部状态、处理外部事件并与外部设备通信的机器。它的一切能力都依赖于代码，而代码由“指令”和“数据”构成；指令决定“做什么”，数据决定“用什么做”。 这些指令与数据都存放在==存储器==中。存储器按地址顺序编排，像在 C 语言里用指针访问内存那样可以被直接访问。它既能存放可执行的指令，也能保存运行时的数据；其中一部分地址被保留映射为寄存器空间，用于连接和控制外部设备，例如通信模块、调试组件或附加存储器。处理器通过访问存储器取回指令编码与数据，配合内部电路完成运算与状态更新，并将结果输出到外部世界。 然而，世界并不总按既定节拍运行。如果——我只是说如果——外部突然发生了意想不到的事件，带来了出乎意料的信息，处理器该如何即时应对？这便引出了下面要讲的核心机制——==中断==。它允许外部事件“打断”当前执行，转入专门的处理流程，以最快的方式给出响应。 怎样理解中断 清晨，工位灯亮起，白板上写着今天的主计划：加工云台支架→装配底盘→校准电机→联调发射机构（主程序/主循环）。lzc戴上手套拧上扭矩扳手，流程稳步推进：测量、钻孔、攻丝、装配（顺序执行）。 忽然，对讲机里传来“场地紧急停机！”（中断源，且为高优先级中断）。lzc立刻在工单上记下当前步骤、扭矩值与零件编号，等于给任务夹上书签（保存现场/入栈），小跑去测试场地，开始快速处置（进入==中断服务程序==/ISR）。他处理完问题在记录表上把这次警报打勾（清中断标志），随后回到工位按“书签”继续拧完那一颗螺丝（出栈返回/恢复现场）。 不一会儿，手机弹出取件码：定制齿轮到了（中断源，低优先级中断）。lzc暂停一下去门口签收、入库并贴标签（ISR只做关键动作），把“尺寸复检与啮合测试”留回主流程再做（回到主程序/主循环）。 签收途中，裁判系统终端又报警：某车小陀螺疯转（中断源，更高优先级中断），直接打断了刚才的快递流程（优先级与嵌套/NVIC）。lzc立刻赶到场边，用毯子将车逼停，随后把这件事压力给电控（清中断标志），再返回把快递流程收尾（出栈返回/恢复现场），最终回到装配主线（主程序/主循环）。 下午联调时，供弹扳机偶尔“连动两下”误报（抖动干扰）。lzc没有在ISR里大动干戈，只记录一次事件并清标志（ISR要短小+清中断标志），随后压力电控在主流程里加电容与软件滤波（去抖动），把“更换按钮/优化线束”安排成后续任务（主程序/主循环处理耗时工作）。 准备做关键总装扭矩前，他把手机与IM系统设为“仅安全员和测试台可打断”（屏蔽/使能中断），避免低优先级事务干扰；完工后再恢复正常通知（重新使能中断）。 一句话收束：机械组的一天，就是单片机中断的现场版——主计划稳步推进（主程序/主循环），突发情况按轻重插队（优先级与嵌套/NVIC）；先记书签（保存现场/入栈），快进快出处理（ISR要点+清中断标志），再回到正事（出栈返回/恢复现场）；必要时开“勿扰”（屏蔽/使能中断），偶发抖动就滤掉（去抖动）。 void Mech_Init(void); void NVIC_Config(void); void Assemble_Gimbal(void); void Assemble_Chassis(void); void Calibrate_Motors(void); int main(void) { Mech_Init(); // 机械组资源初始化（工装、工具、日志、台架…） NVIC_Config(); // 配置中断优先级与使能（仅示意） while (1) { Assemble_Gimbal(); // 装配/调校云台 Assemble_Chassis(); // 装配底盘 Calibrate_Motors(); // 校准电机 } } void EmergencyStop_IRQHandler(void); // 急停（高优先级） void Alert_IRQHandler(void); // 小陀螺异常 void PackageArrived_IRQHandler(void); // 快递到货（低优先级） 工程配置 内容：完成使用按键控制LED的状态 在上次配置的基础上： •根据原理图或PCB图，找到开发板上按键开关对应的单片机引脚。本系列教程STM32CubeMX基础实验采用的开发板中，按键开关对应的引脚为PB3 •将PB3设置为外部中断3号通道 •检测模式选择下降沿 •输入模式选择上拉输入，用于维持平时的高电平 •使能嵌套中断向量控制器 中断的两种优先级默认配置即可 硬件连接： 代码讲解 /* USER CODE BEGIN 4 */ void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) //中断回调函数 { switch(GPIO_Pin) { case KEY_Pin://检测是哪一个引脚发生了外部中断 HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin); break; default: break; } } /* USER CODE END 4 */ 虚函数VS实函数 __weak •本质上是一个宏定义 •实际上的文本对应是编译指令attribute((weak)) 虚函数 •有虚函数指令__weak的函数声明 •虚函数可以有很多个 实函数 •没有虚函数指令__weak的函数声明，也就是普通的函数，都是实函数 •实函数至多有一个，多了会编译报错（如果是C++可以兼容函数重载） •如果实函数存在，则用实函数 •如果实函数不存在，则随机选取一个幸运的虚函数（对我们而言是随机的，但对于编译器而言，也是有一定规则选取的） 程序流程 /******************************************************************************/ /* STM32F1xx Peripheral Interrupt Handlers */ /* Add here the Interrupt Handlers for the used peripherals. */ /* For the available peripheral interrupt handler names, */ /* please refer to the startup file (startup_stm32f1xx.s). */ /******************************************************************************/ /** * @brief This function handles EXTI line3 interrupt. */ void EXTI3_IRQHandler(void)// { /* USER CODE BEGIN EXTI3_IRQn 0 */ /* USER CODE END EXTI3_IRQn 0 */ HAL_GPIO_EXTI_IRQHandler(KEY_Pin); 处理外部中断线（EXTI）的 HAL 函数，在cubemx中配置后生成的，不是我们编写的 /* USER CODE BEGIN EXTI3_IRQn 1 */ /* USER CODE END EXTI3_IRQn 1 */ } /** * @brief This function handles EXTI interrupt request. * @param GPIO_Pin: Specifies the pins connected EXTI line * @retval None */ void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)//检查是否发生外部中断，调用中断回调函数 { /* EXTI line interrupt detected */ if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)//获取是否触发中断 { __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);//清除中断标志位 HAL_GPIO_EXTI_Callback(GPIO_Pin);//调用中断回调函数 } } /** * @brief EXTI line detection callbacks. * @param GPIO_Pin: Specifies the pins connected EXTI line * @retval None */ __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) //虚函数，需要重新定义 { /* Prevent unused argument(s) compilation warning */ UNUSED(GPIO_Pin); /* NOTE: This function Should not be modified, when the callback is needed, the HAL_GPIO_EXTI_Callback could be implemented in the user file */ } void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)//自己实现的实函数 { switch(GPIO_Pin) { case KEY_Pin: HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin); break; default: break; } } 前三段代码都不是自己要写的，都是在CubeMX中配置完就可以直接生成出来的配置代码。 Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-12 11:58:15 "},"sheng-dong-de-xing-xiang-bi-yu-ai-sheng-cheng/wo-men-ru-he-tong-guo-dai-ma-kong-zhi-dan-pian-ji.html":{"url":"sheng-dong-de-xing-xiang-bi-yu-ai-sheng-cheng/wo-men-ru-he-tong-guo-dai-ma-kong-zhi-dan-pian-ji.html","title":"我们如何通过代码控制单片机","keywords":"","body":"我们如何通过代码控制单片机 单片机：一个功能强大的机器人 想象一下，你买来一个非常强大的机器人（这就是单片机，Microcontroller Unit, MCU）。这个机器人身体上集成了很多设备，比如： 它的手臂和腿脚（GPIO引脚，可以输出高低电平来控制LED灯亮灭或检测按键）。 它内置的多个闹钟和秒表（定时器/计数器）。 它的“耳朵”和“嘴巴”，可以用来和别的设备沟通（串行通信接口，如UART, SPI, I2C）。 但是，这个机器人出厂时只会“待机”，你无法直接用语音命令它。你需要一本详细的《机器人控制手册》和一种特殊的“编程语言”来给它下达指令。 寄存器：机器人的“控制面板” 这本《机器人控制手册》（也就是单片机的数据手册 DataSheet）告诉你，机器人的所有功能都是通过它胸前一个巨大、精密、布满了开关和指示灯的控制面板来操作的。 这个控制面板就是寄存器（Register）。 每一个开关/旋钮都对应机器人身体的一个具体功能。比如，A区的1号开关，拨到“开”，机器人左手的LED灯就会亮；拨到“关”，灯就灭。 每一个指示灯则会显示机器人当前的状态。比如，B区的3号指示灯亮了，表示它的“耳朵”（UART接口）听到了外部传来的信息。 这些“开关”和“指示灯”在单片机内部，其实就是一个个极小的、有特定地址的内存单元。它们由成千上万的“0”和“1”组成（二进制位）。 软件/代码：你的“遥控指令” 现在，你作为“程序员”，要做的事情就是编写一段指令代码（通常使用C语言），告诉单片机如何去操作那个“控制面板”（寄存器）。 这个过程分为几步： 查阅手册（阅读DataSheet）： 你想让机器人左臂上的灯闪烁。你翻开手册，在“GPIO”章节找到了说明：“要控制左臂的灯，你需要操作地址编号为 0x4001080C 的那个控制面板（这是一个寄存器的地址）。将这个面板上的第5个开关拨到‘开’（写入‘1’），灯就会亮；拨到‘关’（写入‘0’），灯就会灭。” 编写指令（写C代码）： 你不能真的伸手去拨开关，但你可以通过C语言代码来做到这一点。在C语言中，你可以像操作一个普通变量一样，去操作那个特定地址的“控制面板”。 //这是一段伪代码 // 这是一个“宏定义”，给那个难记的地址起个好记的名字 #define GPIOA_ODR *(volatile unsigned int*)0x4001080C //上面引脚定义地址是库函数帮助开发者做的事情 // 主程序开始 void main() { // 指令1：将第5个开关拨到“开” (通过位运算实现) GPIOA_ODR |= (1 *(volatile unsigned int*)0x4001080C 这段代码就像是你的“魔法手指”，它告诉编译器：“请直接访问物理地址是 0x4001080C 的那个地方，把它当成一个整数来操作。” |= (1 是一个位操作，它精准地将这个“整数”的第5位（对应第5个开关）设置为1，同时不影响其他位（其他开关）。 编译和烧录（发送指令给机器人）： 你写的C代码，通过编译器翻译成机器人唯一能懂的机器语言（一堆0和1）。然后，通过烧录器，将这些机器指令传送到机器人的“大脑”里（单片机的Flash存储器）。 运行（机器人执行指令）： 机器人上电后，它的CPU会一条一条地执行你烧录进去的指令。当它执行到 GPIOA_ODR |= (1 这条时，CPU内部的控制单元就会真的去物理地址 0x4001080C 处，把第5位置为1。瞬间，连接在GPIO引脚上的LED灯就被点亮了。 Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-11 21:13:49 "}}
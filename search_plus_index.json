{"./":{"url":"./","title":"苍穹战队秋招电控培训","summary":"RoboMaster苍穹战队电控培训电子书","keywords":"","body":"苍穹战队秋招电控培训 版本控制 V1.0-添加基础导论和一些相关资料 V1.1-添加新手向学习路线，添加RM论坛资源 V1.2-增加嵌入式导论和初识GPIO V1.3-增加第一次培训内容 V1.4-增加第二次培训内容（中断）和电控校内赛指导 Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-24 18:13:38 "},"0.-dian-kong-dao-lun-ji-di-ling-ke/0.1-dian-kong-dao-lun.html":{"url":"0.-dian-kong-dao-lun-ji-di-ling-ke/0.1-dian-kong-dao-lun.html","title":"0.1电控导论","summary":"***简单介绍电控组的工作***","keywords":"","body":"0.1电控导论 0.1.1电控组介绍 组如其名，我们的工作主要内容就是“电”和“控制”。“电”是指电控组队员要具有独立布置机器人上电线的布局，这需要我们拥有基本的焊接，连线的技能；“控制”是指队员具有独立编写代码用于驱动机器人上各种外设的能力。 (由于往年都会有同学区分不了电控组和视觉组，在这里注重标注一下两组的不同) 项目 电控 视觉（算法组） 专业知识 嵌入式编程，机器人学，自动控制原理…… 计算机视觉，深度学习，ROS…… 编程语言 C语言为主 C++,Python为主 在开发流程中的位置 当机械组和硬件组完成工作后，接下来就是电控来进行机器人外设的驱动 当电控完成基本驱动后，有视觉部署自己的算法，是机器人更加智能（位于开发链的最后一层） 以上内容只是为了帮助各位选取自己更感兴趣的组别加入，为了减少或者杜绝培训后才发现自己想加入的是另外一个组 0.1.2加入电控组你可以收获什么 焊接和布线 自己动手焊接线材，基础电路知识 代码编写能力 C/C++程序设计（基础） 单片机： GPIO输入输出、EXTI中断、TIM中断、PWM波形输出、UART通信协议、ADC等基础内容 ；FreeRTOS、CAN通信、USB虚拟串口 0.1.3学习路线（摘取自中科大开源电控培训（仅供参考和了解）） PS：这个是学习路线图，包括未入队阶段和入队阶段，在此列出只是给各位一个大概的学习思路，不至于特别迷茫（我们的培训只会包含一些基础的课程） 新手学习线路图 0.1.4电控精神 这个是此文档最重要的内容！！！ 0.1.5另外说明 由于本文档使用Gitbook编写，并且为了战队复用，会将此电子书发布到GitHub上托管。所以请各位同学提前学习有关Git的相关知识（我会在后续开一章详细介绍）。 同时为了同学方便查阅，此电子书会本地上传到QQ电控群群文件中。 由于笔者能力有限，有错误和不准确的地方请指出！！！ 再次感谢中科大RoboWalker战队开源的电控教程！！！ Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-12 14:36:28 "},"0.-dian-kong-dao-lun-ji-di-ling-ke/0.2-dian-kong-zi-liao-he-xiang-guan-lian-jie.html":{"url":"0.-dian-kong-dao-lun-ji-di-ling-ke/0.2-dian-kong-zi-liao-he-xiang-guan-lian-jie.html","title":"0.2电控资料和相关链接","keywords":"","body":"0.2电控资料和相关链接 C语言方面 菜鸟教程（电子书）：https://www.runoob.com/cprogramming/c-tutorial.html 浙江大学翁恺（视频）：https://www.bilibili.com/video/BV1dr4y1n7vA/?spm_id_from=333.337.search-card.all.click 嵌入式方面 第一关：软件下载：keil,CubeMax 下载参考文档：2024最新Keilv5下载安装注册及添加ARM5编译器_keil下载-CSDN博客 下载参考视频：[2-1] 软件安装_哔哩哔哩_bilibili 电子扫盲：[喂饭级]一期献给准大学生们的电脑入门喂饭级教程_哔哩哔哩_bilibili 注：配置环境是学习嵌入式的第一关，遇到问题多从网上寻找答案，推荐CSDN,b站 第二关：选择合适的学习开发工具 基础硬件：入门推荐STM32F1系列芯片，这里推荐江科大售卖的套件，够后续持续学 习，也可以从闲鱼找便宜的套件，内包含基础硬件：F103C8T6，面包板，杜邦线，OLED， STLINK 等其余模块传感器。 第三关：学习单片机 推荐b站视频和CSND文档: 1.江科大：STM32入门教程-2023版 细致讲解 中文字幕_哔哩哔哩_bilibili 优点：对于32底层原 理讲的细致，一遍不理解的应当反复观看，更偏重原理 缺点：该视频使用的标准库编写程 序，标准库编写需要自己配置底层，过程显得繁琐，我们要求使用HAL库，借助CubeMax 一键生成底层代码。 2.Keysking: 【STM32入门教程】应该是全B站最好的STM32教程了！！_哔哩哔哩_bilibili优点：使用CubeMAx 编写讲解代码,更偏重应用 缺点：使用CubeIDE编写程序，而我们要求的是使用Keil，该视 频主要学习如何使用CubeMax配置相关底层参数并一键生成，模块介绍不多。 3.Z小旋：【STM32】HAL库 STM32CubeMX系列学习教程_stm32hal库学习路线-CSDN博客优点：文档教学，适合喜欢看文档的，使用CubeMAx 编写代码,理论应用相当 缺点：使用STM32F4板子，而我们一般使用STM32F1但影响不大，可以对照参考学习。 其他资料 rm论坛 里面有很多其他学校或者战队的开源，都是宝贝和学习资源；对于新手来说，里面有”新手任务“，很适合练手，同时也可以再多了解一些rm的信息） https://bbs.robomaster.com/portal.phprm 华南虎搜索引擎（https://search.scutbot.cn/） 适合联手的小项目： https://bbs.robomaster.com/wiki/1350236/88130\\ 后续会不定期更新…… Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-09-01 00:41:13 "},"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.1-qian-ru-shi-wu-liao-gou-mai-ji-huan-jing-xiang-xi-pei-zhi-keil5.html":{"url":"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.1-qian-ru-shi-wu-liao-gou-mai-ji-huan-jing-xiang-xi-pei-zhi-keil5.html","title":"1.1 嵌入式物料购买及环境详细配置（Keil5）","summary":"内容包括软件环境安装及硬件物材购买","keywords":"","body":"1.1 嵌入式物料购买及环境详细配置（Keil5） 硬件物材购买 培训单片机最小系统板为STM32F103C8T6（注意购买的芯片是否为盗版）：建议嘉立创商城购买 (搜索地阔星开发板）（https://wiki.lckfb.com/zh-hans/dkx-stm32f103c8t6/beginner/)； PS：嘉立创开发手册中是标准库，不是我们使用的HAL库 面包板(用于电气连接)，杜邦线（公对公，公对母，母对母）每种大约40根左右就很充足， ST-link（程序下载器） 所需外设： 动力系统：TT电机和电机驱动模块TB6612FNG（可以先随便买一个玩，要用在车上的话需要和机械队友讨论）;舵机模块sg90; 通信控制系统：USB转TTL（串口模块）；蓝牙模块或者2.4G无线通信（取决于小车的控制通信方式）； 电源系统：电池12v;稳压模块（12V转5V；12V转3.3V都要具备） Keil5 环境配置 学习嵌入式主要需要用到Keil5和STM32CUBEMX 一. 安装Keil5： 1. 下载群文件《新人电控一整套》 2. 解压该文件：解压密码：fanbaomiaomiao 3. 安装MDK：点击运行MDK535.EXE文件 4. 在弹出的界面，点击NEXT 5. 勾选I agree，点击Next 6. 记住界面弹出的默认安装的路径，点击Next。在这里有两个注意事项：1.安装路径里面不要有中文！2.不要安装在C:\\Program Files这个文件夹里！ 补充事项：如果想更改安装位置，点击右边的[Browse]，更改的时候也要记住更改的位置，Core和Pack都要记住。 7. 填写用户信息，可以随便填写；点击Next 8. 等待keil5的安装 9. 安装完成后，在弹出的界面中点击Finish 10. 关闭弹出来的Pack Installer窗口：关掉它 11. 激活MDK：在桌面上右击keil图标，在弹出的选项卡中选择以管理员身份运行（很重要很重要！！！） 12. 点击File，选择License Management 13. 复制CID 14. 在安装文件中点击keygen.exe文件（运行前一定静音！！！！！，喜欢刺激的同学可以把声音调到最大） 15. 粘贴复制过的CID，选择Target为ARM，点击Generate，生成激活码 16. 复制生成的激活码，粘贴在New License ID Code处，点击Add LIC，即可成功激活mdk，显示mdk的使用期限 17. 在安装文件中点击Keil.STM32F1xx_DFP.1.1.0.pack 18. 点击Next 进行安装，安装完成后，点击Finish 19. 到此keil5就成功安装并激活了！ 二、安装STM32CUBEMX 1.首先需要安装java环境，运行这个jre开头的文件，完成安装即可，安装路径不要有中文 2.安装完Java后，运行这个Setup开头的文件，完成安装即可，安装路径不要有中文 3.安装这一步时直接默认即可。 4.java和cubemx的具体安装过程可以参考：STM32CubeMX 下载及安装教程_Brendon_Tan的博客-CSDN博客 第三部分： 欧克，到这里Keil5和STM32CUBEMX就全部安装完了！ 驱动安装 设备是通过不同的通信协议来与电脑进行连接，这就要求我们安装驱动程序 有时在设备管理器里查找不到自己连接的器件，这时就要去寻找自己是否安装对应的驱动程序 一般的驱动包含： ST-LINK下载器的驱动程序 USB装TTL串口模块驱动 ...... Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-09-27 21:25:22 "},"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.2-chu-shi-dan-pian-ji.html":{"url":"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.2-chu-shi-dan-pian-ji.html","title":"1.2 初识单片机","summary":"对单片机的简单介绍","keywords":"","body":"1.2 初识单片机 STM32系列单片机 一张图读懂单片机命名，本次培训使用的是最基础的STM32F103C8T6 拿到单片机后，最重要的是去搜索其==原理图==和所拥有的外设资源 https://blog.csdn.net/fantastic_sky/article/details/110229474 对于单片机的详细原理构成这里不做详细讲解，初学者只需知道单片机包含的外设资源就可（GPIO,USART,ADC...） 单片机的简单构成（这部分看不懂也没事） 核心处理器（CPU） 采用32位数据总线和地址总线 常见架构如ARM Cortex-M系列、RISC-V等 具有更强大的运算能力和指令集 存储器 Flash存储器：用于存储程序代码，掉电不会丢失 SRAM：用于存储运行时数据，掉电时全部丢失 ROM：存储引导程序和基本配置 时钟系统 主时钟（通常为外部晶振）单片机的心跳，每一次跳动都代表数据更新（新陈代谢）。 外设接口 GPIO（通用输入输出口） UART/USART（串口通信） SPI（串行外设接口） I2C（双线串行接口） ADC（模数转换器） DAC（数模转换器） USB接口 CAN总线接口等 中断控制器 支持多级中断优先级 向量中断控制 快速中断响应 我们如何通过代码控制单片机 程序员通过C语言等高级语言，编写操作特定内存地址（这些地址就是寄存器的地址）的指令。这些指令被编译成机器码后，由单片机的CPU执行，从而改变寄存器中的值（0或1）。由于寄存器的每一位都与硬件功能（如引脚电平、定时器开关等）物理上关联，因此改变寄存器的值，就直接控制了单片机的硬件行为。 为了方便，芯片厂商通常会提供一个头文件（Header File），里面已经帮你把所有难记的寄存器地址都用好记的名字（如 GPIOA_ODR）定义好了。你只需要引入这个头文件，就可以直接使用这些名字，而不用去记那些复杂的十六进制地址了。这让编程变得更加简单和直观。 这个就是我们常说的库函数 库函数 常见的库函数包含标准库和HAL库（The hardware abstraction layer） 标准库 ST公司就为每款芯片都编写了一份库文件，也就是工程文件里stm32F1xx.....之类的。在这些.c .h文件中，包括一些常用量的宏定义，把一些外设也通过结构体变量封装起来，如GPIO口时钟等。所以我们只需要配置结构体变量成员就可以修改外设的配置寄存器，从而选择不同的功能。是学习STM32接触最多的一种开发方式，我们这次培训并不使用这类库，我也就不多阐述了。 HAL库 HAL库是ST公司目前主力推的开发方式，全称就是Hardware Abstraction Layer（抽象印象层）。库如其名，很抽象，一眼看上去不太容易知道他的作用是什么。它的出现比标准库要晚，但其实和标准库一样，都是为了节省程序开发的时期，而且HAL库尤其的有效，如果说标准库把实现功能需要配置的寄存器集成了，那么HAL库的一些函数甚至可以做到某些特定功能的集成。也就是说，同样的功能，标准库可能要用几句话，HAL库只需用一句话就够了。并且HAL库也很好的解决了程序移植的问题，不同型号的stm32芯片它的标准库是不一样的，例如在F4上开发的程序移植到F3上是不能通用的，而使用HAL库，只要使用的是相通的外设，程序基本可以完全复制粘贴，注意是相通外设，意思也就是不能无中生有，例如F7比F3要多几个定时器，不能明明没有这个定时器却非要配置，但其实这种情况不多，绝大多数都可以直接复制粘贴。而且使用ST公司研发的STMcube软件，可以通过图形化的配置功能，直接生成整个使用HAL库的工程文件，可以说是方便至极，但是方便的同时也造成了它执行效率的低下，在各种论坛帖子真的是被吐槽的数不胜数。 而我们战队主要使用的是HAL库，主要看重其配置方便，而且RM中大多数电控资源也都是HAL库。 工作流程 Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-12 11:58:54 "},"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.3- 使用GPIO点亮板载LED.html":{"url":"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.3- 使用GPIO点亮板载LED.html","title":"1.3 使用GPIO点亮板载LED","keywords":"","body":"使用GPIO点亮板载LED 认识时钟 时钟，是STM32单片机以及各种设备的心跳， 时钟信号是一种高低电平交替变化的脉冲信号。每一次变化（比如从低到高）都代表单片机完成了一个最基本的动作（比如处理一次指令、移动一次数据）。 时钟频率（单位是Hz）决定了单片机运行的快慢。比如8MHz，意思是每秒有800万次“鼓点”。频率越高，单片机工作越快。 单片机要按照一定的顺序来完成各种任务，这就需要有一个统一的“节拍”。时钟让所有部件步调一致，不会乱套。 有低速高速两种（High Speed，HS与Low Speed，LS），低速用于实时时钟（Real Time Clock，RTC）等。 高速用于定时器、UART、ADC等多种外设。 时钟与外设使用 总线连接，外设总线：包括APB1和APB2。 在Cubemx中可以清楚看到时钟总线分配给各种外设。 认识GPIO GPIO综述 GPIO（General Purpose Input/Output，通用输入输出口）可以类比为人体的“手和脚”等，可以与外界进行交互。 从上图可以看到此款单片机的四种GPIO（PA,PB,PC,PD）都是挂载在APB2时钟上的。在cubemx中，我们可以配置GPIO的工作模式以让其发挥我们想要的功能。 GPIO的八种工作模式 输出模式VS输入模式 ”写“可以理解为将此引脚置为高电平；”读“可以理解为感应此引脚的电平。 推挽模式（Push-Pull）VS开漏模式（Open-Drain） 推挽模式 推挽模式下，GPIO端口内部有两个晶体管，一个连接电源，一个连接地。 当输出高电平时，上方晶体管导通，端口直接输出电源电压（如3.3V或5V）。 当输出低电平时，下方晶体管导通，端口直接输出地（0V）。 能够主动输出高、低电平，驱动能力强，适合直接驱动LED、继电器等负载。 ==宁折不弯，推挽高低电平相遇会烧坏== 开漏模式 开漏模式下，GPIO端口内部只有一个下拉晶体管，连接地。 当输出低电平时，晶体管导通，端口接地（0V）。 当输出高电平时，晶体管关闭，端口处于悬空（不输出电压），需要外部上拉电阻将端口拉到高电平。 ==不能主动输出高电平，只能“拉低”或“释放”。== 复用VS通用 从上图可以看出通用输出是由CPU直接控制引脚；复用输出用于外设对引脚有特殊要求（绑定了特定MCU内功能输出），其实就是用作其他外设的专用引脚。 输入的四种模式 输入上拉和下拉就是默认状态下该引脚的电平为高电平3.3V，0V。 浮空输入模式下，电平的状态飘忽不定，测量时可能出现0~3.3V之间的任意电压值。 输入模拟与前三种输入模式不同，它是唯一可以读取模拟量（即连续时间连续值），其他都是数字信号输入。 点亮单片机板载LED 首先当我们想要完成某一个功能时，一定要有理论知识去支撑我们完成这个功能，那么我们需要知道点亮LED灯的原理，知道原理后我们才能有根据的配置32单片机外设和编写代码。 LED原理 LED在这里是指发光二极管，二极管导通的条件是给其施加一个正向电压就行。 如上图所示，我们需要配置好一个电子回路。该庆幸的是板载最小系统板在设计的时候就已经有帮我们设计好了的电路。 如上图，D1在系统板上电是就会一直处于导通状态，而D2的状态完全处于PC13，所以接下我们要做的的就是控制PC13引脚进而控制D2的状态。 CubeMX的工程配置 STM32F103C8T6基础开发教程（HAL库）—点亮第一颗LED灯_stm32f103c8t6 教程-CSDN博客 具体操作可以看这篇博客，操作基本都有讲解。 ==PS：自己的LED引脚可能与这篇文章作者不同，请根据实际情况来操作== ==•Keil中，取消编译优化，打开C99，以及—cpp11== ==•Reset and run== 在这里点一下最重要，也是基本每次配置工程都会用到的两步 选择调试模式，如果不选你无法使用stlink这类下载工具； 选择时钟源 代码编写 while (1) { /* USER CODE END WHILE */ HAL_GPIO_WritePin(LED_GPIO_Port,LED_Pin,GPIO_PIN_SET);//用户编写的只有这个一段代码实现灯常亮 // GPIOx：对应的 GPIO 端口。例如 LED_GPIO_Port 可能是 GPIOA、GPIOB 等。 // GPIO_Pin：要操作的引脚。例如 LED_Pin，一般是类似 GPIO_PIN_1、GPIO_PIN_5 这样的宏。 // PinState：设置引脚的电平状态。可以是： // GPIO_PIN_SET：将引脚设置为高电平（输出为 1） // GPIO_PIN_RESET：将引脚设置为低电平（输出为 0） HAL_Delay(1000);//延时函数，单位为ms,这里起到的作用是使led灯一秒改变一次状态; /* USER CODE BEGIN 3 */ } Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-11 23:09:36 "},"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.4-中断.html":{"url":"1.-qian-ru-shi-dao-lun-he-chu-shi-gpio/1.4-中断.html","title":"1.4 中断","keywords":"","body":"外部中断EXTI 单片机执行原理（暂时看不懂没事） 从抽象上看，==处理器系统==是一台能运算数据、操控内部状态、处理外部事件并与外部设备通信的机器。它的一切能力都依赖于代码，而代码由“指令”和“数据”构成；指令决定“做什么”，数据决定“用什么做”。 这些指令与数据都存放在==存储器==中。存储器按地址顺序编排，像在 C 语言里用指针访问内存那样可以被直接访问。它既能存放可执行的指令，也能保存运行时的数据；其中一部分地址被保留映射为寄存器空间，用于连接和控制外部设备，例如通信模块、调试组件或附加存储器。处理器通过访问存储器取回指令编码与数据，配合内部电路完成运算与状态更新，并将结果输出到外部世界。 然而，世界并不总按既定节拍运行。如果——我只是说如果——外部突然发生了意想不到的事件，带来了出乎意料的信息，处理器该如何即时应对？这便引出了下面要讲的核心机制——==中断==。它允许外部事件“打断”当前执行，转入专门的处理流程，以最快的方式给出响应。 怎样理解中断 清晨，工位灯亮起，白板上写着今天的主计划：加工云台支架→装配底盘→校准电机→联调发射机构（主程序/主循环）。lzc戴上手套拧上扭矩扳手，流程稳步推进：测量、钻孔、攻丝、装配（顺序执行）。 忽然，对讲机里传来“场地紧急停机！”（中断源，且为高优先级中断）。lzc立刻在工单上记下当前步骤、扭矩值与零件编号，等于给任务夹上书签（保存现场/入栈），小跑去测试场地，开始快速处置（进入==中断服务程序==/ISR）。他处理完问题在记录表上把这次警报打勾（清中断标志），随后回到工位按“书签”继续拧完那一颗螺丝（出栈返回/恢复现场）。 不一会儿，手机弹出取件码：定制齿轮到了（中断源，低优先级中断）。lzc暂停一下去门口签收、入库并贴标签（ISR只做关键动作），把“尺寸复检与啮合测试”留回主流程再做（回到主程序/主循环）。 签收途中，裁判系统终端又报警：某车小陀螺疯转（中断源，更高优先级中断），直接打断了刚才的快递流程（优先级与嵌套/NVIC）。lzc立刻赶到场边，用毯子将车逼停，随后把这件事压力给电控（清中断标志），再返回把快递流程收尾（出栈返回/恢复现场），最终回到装配主线（主程序/主循环）。 下午联调时，供弹扳机偶尔“连动两下”误报（抖动干扰）。lzc没有在ISR里大动干戈，只记录一次事件并清标志（ISR要短小+清中断标志），随后压力电控在主流程里加电容与软件滤波（去抖动），把“更换按钮/优化线束”安排成后续任务（主程序/主循环处理耗时工作）。 准备做关键总装扭矩前，他把手机与IM系统设为“仅安全员和测试台可打断”（屏蔽/使能中断），避免低优先级事务干扰；完工后再恢复正常通知（重新使能中断）。 一句话收束：机械组的一天，就是单片机中断的现场版——主计划稳步推进（主程序/主循环），突发情况按轻重插队（优先级与嵌套/NVIC）；先记书签（保存现场/入栈），快进快出处理（ISR要点+清中断标志），再回到正事（出栈返回/恢复现场）；必要时开“勿扰”（屏蔽/使能中断），偶发抖动就滤掉（去抖动）。 void Mech_Init(void); void NVIC_Config(void); void Assemble_Gimbal(void); void Assemble_Chassis(void); void Calibrate_Motors(void); int main(void) { Mech_Init(); // 机械组资源初始化（工装、工具、日志、台架…） NVIC_Config(); // 配置中断优先级与使能（仅示意） while (1) { Assemble_Gimbal(); // 装配/调校云台 Assemble_Chassis(); // 装配底盘 Calibrate_Motors(); // 校准电机 } } void EmergencyStop_IRQHandler(void); // 急停（高优先级） void Alert_IRQHandler(void); // 小陀螺异常 void PackageArrived_IRQHandler(void); // 快递到货（低优先级） 工程配置 内容：完成使用按键控制LED的状态 在上次配置的基础上： •根据原理图或PCB图，找到开发板上按键开关对应的单片机引脚。本系列教程STM32CubeMX基础实验采用的开发板中，按键开关对应的引脚为PB3 •将PB3设置为外部中断3号通道 •检测模式选择下降沿 •输入模式选择上拉输入，用于维持平时的高电平 •使能嵌套中断向量控制器 中断的两种优先级默认配置即可 硬件连接： 代码讲解 /* USER CODE BEGIN 4 */ void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) //中断回调函数 { switch(GPIO_Pin) { case KEY_Pin://检测是哪一个引脚发生了外部中断 HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin); break; default: break; } } /* USER CODE END 4 */ 虚函数VS实函数 __weak •本质上是一个宏定义 •实际上的文本对应是编译指令attribute((weak)) 虚函数 •有虚函数指令__weak的函数声明 •虚函数可以有很多个 实函数 •没有虚函数指令__weak的函数声明，也就是普通的函数，都是实函数 •实函数至多有一个，多了会编译报错（如果是C++可以兼容函数重载） •如果实函数存在，则用实函数 •如果实函数不存在，则随机选取一个幸运的虚函数（对我们而言是随机的，但对于编译器而言，也是有一定规则选取的） 程序流程 /******************************************************************************/ /* STM32F1xx Peripheral Interrupt Handlers */ /* Add here the Interrupt Handlers for the used peripherals. */ /* For the available peripheral interrupt handler names, */ /* please refer to the startup file (startup_stm32f1xx.s). */ /******************************************************************************/ /** * @brief This function handles EXTI line3 interrupt. */ void EXTI3_IRQHandler(void)// { /* USER CODE BEGIN EXTI3_IRQn 0 */ /* USER CODE END EXTI3_IRQn 0 */ HAL_GPIO_EXTI_IRQHandler(KEY_Pin); 处理外部中断线（EXTI）的 HAL 函数，在cubemx中配置后生成的，不是我们编写的 /* USER CODE BEGIN EXTI3_IRQn 1 */ /* USER CODE END EXTI3_IRQn 1 */ } /** * @brief This function handles EXTI interrupt request. * @param GPIO_Pin: Specifies the pins connected EXTI line * @retval None */ void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)//检查是否发生外部中断，调用中断回调函数 { /* EXTI line interrupt detected */ if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)//获取是否触发中断 { __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);//清除中断标志位 HAL_GPIO_EXTI_Callback(GPIO_Pin);//调用中断回调函数 } } /** * @brief EXTI line detection callbacks. * @param GPIO_Pin: Specifies the pins connected EXTI line * @retval None */ __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) //虚函数，需要重新定义 { /* Prevent unused argument(s) compilation warning */ UNUSED(GPIO_Pin); /* NOTE: This function Should not be modified, when the callback is needed, the HAL_GPIO_EXTI_Callback could be implemented in the user file */ } void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)//自己实现的实函数 { switch(GPIO_Pin) { case KEY_Pin: HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin); break; default: break; } } 前三段代码都不是自己要写的，都是在CubeMX中配置完就可以直接生成出来的配置代码。 Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-17 22:03:16 "},"2.-qian-ru-shi-ding-shi-qi-pwm/2.1-认识定时器.html":{"url":"2.-qian-ru-shi-ding-shi-qi-pwm/2.1-认识定时器.html","title":"2.1-认识定时器","keywords":"","body":"认识定时器 基本概述 定时器（Timer/Counter）是微控制器中负责计时和计数的硬件模块。它通过一个时钟源进行递增或递减计数，用以产生精确的时间间隔、测量事件间隔或生成周期性波形。 主要组成部分： 时钟源（内部系统时钟或外部时钟） 分频器（Prescaler） 计数寄存器（Counter/Timer Register） 比较/捕获寄存器（Compare/Capture Registers） 中断/事件控制逻辑。 常见工作模式： 基本计数/溢出模式（Normal/Overflow）：计数器递增到最大值后溢出并归零，通常产生溢出中断用于周期性任务。 比较匹配（CTC/Compare）：当计数值等于比较寄存器时触发事件或中断，便于产生精确定时或定时复位。 PWM（脉宽调制）模式：计数器与比较寄存器配合，通过改变“高电平持续时间”占空比来生成用于驱动电机或调光的PWM信号。 输入捕获（Input Capture）：记录外部事件发生时的计数值，用于测量脉宽或频率。 外部触发/同步模式：允许外部信号启动、停止或同步计数。 计数模式 通用定时器有向上计数、向下计数、向上向下双向计数模式。 向上计数模式：计数器从0计数到自动加载值（TIMx_ARR），然后重新从0开始计数并且产生一个计数器溢出事件。 向下计数模式：计数器从自动装入的值（TIMx_ARR）开始向下计数到0，然后从自动装入的值重新开始，并产生一个计数器向下溢出事件。 中央对齐模式（向上/向下计数）：计数器从0开始计数到自动装入的值-1，产生一个计数器溢出事件，然后向下计数到1并且产生一个计数器溢出事件；然后再从0开始重新计数。 简单地理解三种计数模式，可以通过下面的图形： Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-15 14:11:26 "},"2.-qian-ru-shi-ding-shi-qi-pwm/2.2-定时器中断.html":{"url":"2.-qian-ru-shi-ding-shi-qi-pwm/2.2-定时器中断.html","title":"2.2-定时器中断","keywords":"","body":"定时器中断 为什么要使用定时器中断？ 想象你的手机里装了一个超级可靠的小闹钟——它会在你设置的时间“悄悄”提醒你：该起床了、该吃饭了、该打游戏了。定时器中断就是这样一个闹钟：当时间到或发生特定事件时，它会立刻“敲门”告诉CPU，“嘿，有事儿要处理！”CPU会暂时放下当前任务，去处理这个“敲门”的事情（运行中断服务程序，简称ISR），处理完再继续未完成的工作。 定时器中断最大的好处就是​​高效​​。如果没有它，想让一个LED灯每秒闪烁一次，CPU就只能不断地查询时间：“到1秒了吗？到1秒了吗？”，在这段时间里它什么别的也干不了，这被称为“忙等待”或“死等”，效率极低。 而有了定时器中断，CPU就可以​​“一心二用”​​。在定时器默默计时的背景之下，CPU可以腾出精力去执行其他任务，只在需要的时候被“打断”一下去处理定时任务。这样就极大地提高了单片机的工作效率。 总而言之，定时器中断就是一个让单片机能够高效、精准地处理时间相关任务的幕后功臣。 怎样使用定时器中断？ 配置时钟树 这一部分的原理不做过多介绍，感兴趣的同学可以自行查看 时钟树配置视频 我们打开上一次的工程，选择System Core,选择RCC,将High Speed Clock改为Crystal/Ceramic Resonator。 然后选择Clock Configuration,选择HSE,选择PLLCLK,将HCLK改为72MHz,软件会自动帮我们完成其他配置。 配置定时器 选择左侧栏中的Timers,选择TIM2，将Clock Source选择为Internal Clock 我们选择让定时器定时一秒，定时器周期可由如下公式获得： T = (psc+1)(arr+1)/fclk 在Configuration栏中对定时器预分频系数和自动重装载值进行配置，选中Prescaler将其更改为7200-1,选中Internal Clock Division将其更改为10000-1 选中NVIC Settings,勾选TIM2 global interrupt Enabled，以打开定时器中断 编写定时器中端处理程序 将以下程序添加到main.c中，程序将在执行完中断后进入此中断处理函数，实现A1端口的翻转。 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim == (&htim2)) { HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_8); } } 在主程序中开启定时器 定时器只有经过使能才能开始工作，stm32 hal库中，开启定时器中断的函数如下： HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim); 我们在主函数的开始调用该函数使能定时器，就能使定时器开始工作，并以我们设定的周期进入中断处理函数，实现GPIO口的电平翻转 int main(void) { ... /* USER CODE BEGIN 2 */ HAL_TIM_Base_Start_IT(&htim2); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } 效果如下： Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-17 22:27:42 "},"2.-qian-ru-shi-ding-shi-qi-pwm/2.3-PWM波输出.html":{"url":"2.-qian-ru-shi-ding-shi-qi-pwm/2.3-PWM波输出.html","title":"2.3-PWM波输出","keywords":"","body":"PWM波输出 什么是PWM 脉冲宽度调制(PWM)，是英文“Pulse Width Modulation”的缩写，简称脉宽调制，是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术，广泛应用在从测量、通信到功率控制与变换的许多领域中。 简单来说，pwm就是如上图所示的方波。 为什么需要 PWM？ 设想你要控制电机速度或调节灯的亮度。直觉上，常见的做法是改变电压：电压越高，输出能量越大，设备响应越强。但单片机的 GPIO 通常只能输出两个数字电平（如 0V 与 3.3V/5V），无法直接输出连续的模拟电压；虽然可以用 DAC，但成本和资源开销较大。 PWM 提供了一种低成本且高效的替代方式：通过在固定频率下改变“高电平持续时间”的比例（占空比），在时间上调节输出能量的平均值。这样，外部负载（如电机或 LED）看到的是一个平均能量，而不是连续变化的电压。 怎样输出PWM 我们打开上次定时器中断的工程，选择TIM4,勾选Ineteral Clock 选择Channel1 的PWM Generation CH1 选择Prescaler,将其更改为720-1；选择Counter Period，将其更改为100-1,根据公式： T = (psc+1)(arr+1)/fclk 可知我们设置的pwm频率为1khz 然后修改TIM2的Prescaler及Counter Period如下： 通过上述修改，定时器中断的周期变为10ms。 点击Generate Code并进入keil工程，在main函数中添加pwm使能代码如下： int main(void) { ... /* USER CODE BEGIN 2 */ HAL_TIM_Base_Start_IT(&htim2); HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_1); /* USER CODE END 2 */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } 怎样修改占空比 我们通过修改CCR的方式对输出pwm波的占空比进行修改， 所用到的函数如下: __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_1, pwmVa); 其中，第一个参数是输出pwm所用的定时器，第二个参数是输出pwm的通道，第三个参数是所要修改的CCR值。其中占空比的公式为： Duty = CCR / (ARR + 1) PWM控制呼吸灯 基于上节课实现的定时器中断以及这节课的PWM输出，我们可以实现呼吸灯的效果，即随着时间变化，pwm输出占空比不断变化，实现led亮暗的转换。 我们先在main.c的上方添加tim4_channel1_pulse、tim4_channel1_pulse_dir的定义，以存储CCR值、控制pulse增加减少方向如下： uint8_t tim4_channel1_pulse = 0; uint8_t tim4_channel1_pulse_dir = 0; 接着在上节课使用过的中断回调函数HAL_TIM_PeriodElapsedCallback中添加如下代码： void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim == (&htim2)) { HAL_GPIO_TogglePin(GPIOA,GPIO_PIN_8); if(tim4_channel1_pulse_dir == 0) { tim4_channel1_pulse++; } else { tim4_channel1_pulse--; } if(tim4_channel1_pulse>=100) { tim4_channel1_pulse_dir = 1; } else if(tim4_channel1_pulse 效果如下： Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-17 22:28:04 "},"3.-通信模式/3.1通信模式.html":{"url":"3.-通信模式/3.1通信模式.html","title":"3.1-通信模式","keywords":"","body":"通信模式 🧩 一、通信的目的与协议 通信的目的： 👉 将一个设备的数据发送到另一个设备，实现信息交互或硬件扩展。比如：主控 MCU 读取传感器数据，或与电脑交换数据。 通信协议： 👉 制定通信双方的规则（格式、时序、电平等），使得双方能按照统一标准正确地收发数据。 名称 引脚 双工 时钟 电平 设备结构 USART TX、RX 全双工 异步 单端 点对点 I2C SCL、SDA 半双工 同步 单端 多设备 SPI SCLK、MOSI、MISO、CS 全双工 同步 单端 多设备 CAN CAN_H、CAN_L 半双工 异步 差分 多设备 USB DP、DM 半双工 异步 差分 点对点 全双工：可以同时发送和接收；像打电话，两人能同时说、同时听 半双工：不能同时进行，只能一方发、一方收；不能同时进行，只能一方发、一方收 异步：无独立时钟线，双方各自时钟 同步：有独立时钟线，主设备提供 串口通信： 参数及时序 波特率：串口通信的速率 起始位：标志一个数据帧的开始，固定为低电平 数据位：数据帧的有效载荷，1为高电平，0为低电平，低位先行 校验位：用于数据验证，根据数据位计算得来 停止位：用于数据帧间隔，固定为高电平 STM32CubeMx的具体配置 1.设置RCC 设置高速外部时钟HSE 选择外部时钟源 2.设置烧录口 设置Debug: Serial Wire 3.设置串口 1点击USATR1 2设置MODE为异步通信(Asynchronous) 3基础参数：波特率为115200 Bits/s。传输数据长度为8 Bit。奇偶检验无，停止位1 接收和发送都使能 4GPIO引脚设置 USART1_RX/USART_TX 5 NVIC Settings 一栏使能接收中断 4.设置时钟 注：这里输入72就可以了 5.项目文件设置 1 设置项目名称 2 设置存储路径 3 选择所用IDE 6.创建工程文件 然后点击GENERATE CODE 创建工程 配置下载工具 新建的工程所有配置都是默认的 我们需要自行选择下载模式，勾选上下载后复位运行 修改代码优化等级：选择不优化 然后编译 没有问题就可以正常编译代码； 有问题的话：推荐解决方法 浏览器搜索：CSDN，然后在csdn里面搜索自己的问题 浏览器搜索Ai工具像：deepseek,腾讯元宝，豆包，然后输入自己的问题 HAL库UART函数库介绍 1、串口发送/接收函数 HAL_UART_Transmit();串口发送数据，使用超时管理机制 HAL_UART_Receive();串口接收数据，使用超时管理机制 HAL_UART_Transmit_IT();串口中断模式发送 HAL_UART_Receive_IT();串口中断模式接收 HAL_UART_Transmit_DMA();串口DMA模式发送 HAL_UART_Transmit_DMA();串口DMA模式接收 这几个函数的参数基本都是一样的，我们挑两个讲解一下 HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout) 功能：串口发送指定长度的数据。如果超时没发送完成，则不再发送，返回超时标志（HAL_TIMEOUT）。 参数： UART_HandleTypeDef *huart UATR的别名 如 : UART_HandleTypeDef huart1; 别名就是huart1 *pData 需要发送的数据 Size 发送的字节数 Timeout 最大发送时间，发送数据超过该时间退出发送 举例： HAL_UART_Transmit(&huart1, (uint8_t *)ZZX, 3, 0xffff); //串口发送三个字节数据，最大传输时间0xffff HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) 功能：串口中断接收，以中断方式接收指定长度数据。 大致过程是，设置数据存放位置，接收数据长度，然后使能串口接收中断。接收到数据时，会触发串口中断。 再然后，串口中断函数处理，直到接收到指定长度数据，而后关闭中断，进入中断接收回调函数，不再触发接收中断。(只触发一次中断) 参数： UART_HandleTypeDef *huart UATR的别名 如 : UART_HandleTypeDef huart1; 别名就是huart1 *pData 接收到的数据存放地址 Size 接收的字节数 举例： HAL_UART_Receive_IT(&huart1,(uint8_t *)&value,1); //中断接收一个字符，存储到value中 2、串口中断函数 HAL_UART_IRQHandler(UART_HandleTypeDef *huart); //串口中断处理函数 HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart); //串口发送中断回调函数 HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart); //串口发送一半中断回调函数（用的较少） HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart); //串口接收中断回调函数 HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart);//串口接收一半回调函数（用的较少） HAL_UART_ErrorCallback();串口接收错误函数 ==串口接收中断回调函数：== HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart); 功能：HAL库的中断进行完之后，并不会直接退出，而是会进入中断回调函数中，用户可以在其中设置代码， 串口中断接收完成之后，会进入该函数，该函数为空函数，用户需自行修改， 参数： UART_HandleTypeDef *huart UATR的别名 如 : UART_HandleTypeDef huart1; 别名就是huart1 举例： HAL_UART_RxCpltCallback(&huart1){ //用户设定的代码 } 串口中断处理函数 HAL_UART_IRQHandler(UART_HandleTypeDef *huart); 功能：对接收到的数据进行判断和处理 判断是发送中断还是接收中断，然后进行数据的发送和接收，在中断服务函数中使用 如果接收数据，则会进行接收中断处理函数 3.串口查询函数 HAL_UART_GetState(); 判断UART的接收是否结束，或者发送数据是否忙碌 举例： while(HAL_UART_GetState(&huart4) == HAL_UART_STATE_BUSY_TX) //检测UART发送结束 USART接收与发送 重新定义printf函数 包含 include /* USER CODE BEGIN Includes */ #include \\ /* USER CODE END Includes */ 勾选Use MicroLIB /* Private user code ---------------------------------------------------------*/ /* USER CODE BEGIN 0 */ 在这重写fgett函数 /* USER CODE END 0 */ 在主循环添加测试代码 可以看到上位机接收我们发送到的数据 注意：一开始使用这个可能会乱码，需要更改中文编码设置 UART接收中断 因为中断接收函数只能触发一次接收中断，所以我们需要在中断回调函数中再调用一次中断接收函数 1、初始化串口 2、在main中第一次调用接收中断函数 3、进入接收中断，接收完数据 进入中断回调函数 4、修改HAL_UART_RxCpltCallback中断回调函数，处理接收的数据， 5 回调函数中要调用一次HAL_UART_Receive_IT函数，使得程序可以重新触发接收中断 上位机发送信息 数据包 一般互相通信，通常会选择制定一个数据包来发送和解析 格式：[包头] [数据区] [包尾](其中包头、数据区、包尾的总长度是固定的) 看看效果 Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-26 00:08:55 "},"4.控制理论基础/4.1PID控制算法理论.html":{"url":"4.控制理论基础/4.1PID控制算法理论.html","title":"4.1-PID控制算法理论","keywords":"","body":"4.1PID控制算法理论 1.什么是控制，为什么要控制 这里不做学术上的解释，控制可以简单被理解为让被控对象达成我们想要的动作。 大家校内赛去驱动电机，输入不同的占空比，就是为了让电机输出一定的转速，但是由于一些其他的原因（机械装配阻力，轮子在地面上打滑），导致我们可能输入的是一个期望值(ref)，但其实电机转动的速度（measure）并不是我们期望的速度，这就导致了误差（error），上述的控制方式被称为开环控制1，而不同的控制算法就是为了尽量减少误差。 PS:为了给大家提供编程思路，上面这些期望值等我会用ref等英文代替。 这里仅介绍最基础的控制算法PID，还有其他的控制算法例如LQR，MPC，还需大家自己探索 2.理解PID PID三个字母已经把这个算法的核心全盘托出，P->比例kp,I->积分ki，D->微分项kd,这三个参数会对误差做不同的处理，然后输出各自的out以弥补测量值和期望值之间的误差。 整个流程如上整个系统框图所示，输入就是ref，你可以看到有个加号，说明他是正值输入系统，还可以看到测量元件的输出measure是负值，于是我们得到error=（ref-measure）。然后得到error后，你可以看到其作为下一级的输入，输入到三个调节器中做不同处理，你大可以理解这三个调节器是并联的，并且你可以通过编程选择开启其中的某条通路，最后三个调节器的输出相加作为执行机构的输入。（公式与调节器相对应） 比例调节器Kp 比例调节器的输出是Kperror，假设你输入的电机ref为1000，但是测量器件得到的measure为800，那么此调节器的输出就是200 kp，这个特性也注定，这个参数是三个调节器最重要的部分，他是补充误差的大哥，一般来说补充误差最多的就是比例调节器。 积分调节器Ki 但是从上述控制是不足够，你是不是以为将kp设为1，然后输出正好是误差的值，这样整个系统就变成非常完美了。但是从工程上来讲，影响因素太多，这种理想状态不太可能存在，并且在大多数的工况下，我们不可能只是用单环PID，可能是多个PID级联（PID环的输入和输出物理意义不同），典型例子如（外环角度环，内环速度环），多环PID都是后话。所以就算我们将比例调节器的输出结果输入到电机中，我们还是无法保证其的测量值measure就是1000，比例调节器只是减少了误差。 综上，我们引入了积分调节器Ki，用于进一步减小误差，他的输出值是对误差的积分，假如第一个单片机运行周期内其误差是200，第二个是100，那么其输出就是ki * （200+100）这样，这样这个pid公式就进化为 $$ u=kp*error+ ki∗∫ error $$ 于加入了积分项的存在，会让输入增大，从而使得速度慢慢接近ref,这就是积分项的作用。 微分调节器 误差的微分就是误差的变化速率，误差变化越快，其微分绝对值越大。误差增大时，其微分为正;误差减小时，其微分为负。控制器输出量的微分部分与误差的微分成正比，反映了被控量变化的趋势。微分作用可以缩短过渡过程和减小动差。但因为它不能消除偏差，所以微分作用不能单独使用，而是同比例积分等组成联合动作的调节器。加入微分调节器是为减小超调现象 总结 3.PID算法的实现思路 硬件需求 ==带有编码器的电机（与不同电机来讲，其可以提供测量值）== 软件思路 先弄清我们需要哪些变量，根据原理，我们需要很多数据，不如我们使用结构体去构造一个PID的实例。那么我们需要指导结构体里面要有哪些变量。 typedef struct { float ref; //目标值 float err; //偏差值 float err_last; //上一个偏差值 float Kp,Ki,Kd; //比例、积分、微分系数 float integral; //积分值 float output_val; //输出值 } PIDInstance; 有了这个就可对各个pid实例进行操作了，即实现PID算法 float PID_realize(float actual_val) { /*计算目标值与实际值的误差*/ pid.err = pid.target_val - actual_val; /*积分项*/ pid.integral += pid.err; /*PID算法实现*/ pid.output_val = pid.Kp * pid.err + pid.Ki * pid.integral + pid.Kd * (pid.err - pid.err_last); /*误差传递*/ pid.err_last = pid.err; /*返回当前实际值*/ return pid.output_val; } 4.调整pid参数 对于电控来说，这个会是最痛苦的环节，在这里没有太多经验介绍，因为该怎么调上网一搜都有，但是只有自己亲手调过，才能真的有所收获 参考资料 【1】(99+ 封私信 / 74 条消息) PID控制算法原理（抛弃公式，从本质上真正理解PID控制） - 知乎 【2】(99+ 封私信 / 76 条消息) 详解PID调节的基本概念、参数与调试方法，清晰易懂！ - 知乎 【3】电机控制进阶——PID速度控制_电机 pid 算法-CSDN博客 1. 开环控制是一种无反馈的控制方式，其特点是控制信号单向作用于被控对象，无法根据输出结果进行调整。 ↩ Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-11-04 20:28:56 "},"sheng-dong-de-xing-xiang-bi-yu-ai-sheng-cheng/wo-men-ru-he-tong-guo-dai-ma-kong-zhi-dan-pian-ji.html":{"url":"sheng-dong-de-xing-xiang-bi-yu-ai-sheng-cheng/wo-men-ru-he-tong-guo-dai-ma-kong-zhi-dan-pian-ji.html","title":"我们如何通过代码控制单片机","keywords":"","body":"我们如何通过代码控制单片机 单片机：一个功能强大的机器人 想象一下，你买来一个非常强大的机器人（这就是单片机，Microcontroller Unit, MCU）。这个机器人身体上集成了很多设备，比如： 它的手臂和腿脚（GPIO引脚，可以输出高低电平来控制LED灯亮灭或检测按键）。 它内置的多个闹钟和秒表（定时器/计数器）。 它的“耳朵”和“嘴巴”，可以用来和别的设备沟通（串行通信接口，如UART, SPI, I2C）。 但是，这个机器人出厂时只会“待机”，你无法直接用语音命令它。你需要一本详细的《机器人控制手册》和一种特殊的“编程语言”来给它下达指令。 寄存器：机器人的“控制面板” 这本《机器人控制手册》（也就是单片机的数据手册 DataSheet）告诉你，机器人的所有功能都是通过它胸前一个巨大、精密、布满了开关和指示灯的控制面板来操作的。 这个控制面板就是寄存器（Register）。 每一个开关/旋钮都对应机器人身体的一个具体功能。比如，A区的1号开关，拨到“开”，机器人左手的LED灯就会亮；拨到“关”，灯就灭。 每一个指示灯则会显示机器人当前的状态。比如，B区的3号指示灯亮了，表示它的“耳朵”（UART接口）听到了外部传来的信息。 这些“开关”和“指示灯”在单片机内部，其实就是一个个极小的、有特定地址的内存单元。它们由成千上万的“0”和“1”组成（二进制位）。 软件/代码：你的“遥控指令” 现在，你作为“程序员”，要做的事情就是编写一段指令代码（通常使用C语言），告诉单片机如何去操作那个“控制面板”（寄存器）。 这个过程分为几步： 查阅手册（阅读DataSheet）： 你想让机器人左臂上的灯闪烁。你翻开手册，在“GPIO”章节找到了说明：“要控制左臂的灯，你需要操作地址编号为 0x4001080C 的那个控制面板（这是一个寄存器的地址）。将这个面板上的第5个开关拨到‘开’（写入‘1’），灯就会亮；拨到‘关’（写入‘0’），灯就会灭。” 编写指令（写C代码）： 你不能真的伸手去拨开关，但你可以通过C语言代码来做到这一点。在C语言中，你可以像操作一个普通变量一样，去操作那个特定地址的“控制面板”。 //这是一段伪代码 // 这是一个“宏定义”，给那个难记的地址起个好记的名字 #define GPIOA_ODR *(volatile unsigned int*)0x4001080C //上面引脚定义地址是库函数帮助开发者做的事情 // 主程序开始 void main() { // 指令1：将第5个开关拨到“开” (通过位运算实现) GPIOA_ODR |= (1 *(volatile unsigned int*)0x4001080C 这段代码就像是你的“魔法手指”，它告诉编译器：“请直接访问物理地址是 0x4001080C 的那个地方，把它当成一个整数来操作。” |= (1 是一个位操作，它精准地将这个“整数”的第5位（对应第5个开关）设置为1，同时不影响其他位（其他开关）。 编译和烧录（发送指令给机器人）： 你写的C代码，通过编译器翻译成机器人唯一能懂的机器语言（一堆0和1）。然后，通过烧录器，将这些机器指令传送到机器人的“大脑”里（单片机的Flash存储器）。 运行（机器人执行指令）： 机器人上电后，它的CPU会一条一条地执行你烧录进去的指令。当它执行到 GPIOA_ODR |= (1 这条时，CPU内部的控制单元就会真的去物理地址 0x4001080C 处，把第5位置为1。瞬间，连接在GPIO引脚上的LED灯就被点亮了。 Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-11 21:13:49 "},"校内赛电控指导/电控校内赛思路梳理.html":{"url":"校内赛电控指导/电控校内赛思路梳理.html","title":"电控校内赛思路梳理","keywords":"","body":"电控校内赛思路梳理 目录 电控校内赛物料准备 校内赛电控能力梳理 电控小车电控系统组成和思路分享 ... 电控校内赛物料准备 主控：STM32系列单片机； 电源管理模块：电池，电池盒（注意买三个装的电池盒，电池就要是3个），充电器，电压转换模块，开关； 遥控系统：蓝牙模块； 底盘：电机；电机驱动模块（注意一个驱动芯片最多只能控制两个电机）（具体数量请与机械商量） 云台（射击或者抓矿的结构）：同底盘，舵机； ==PS：注意电压转换模块的负载能力，有时挂载外设过多时，超出模块额定电流，会出现一些失常的现象== 电控能力梳理 焊接与布线能力 包括并且不限于可以自主焊接排针到最小系统板；可以自主焊接杜邦线与电机进行连接。 可以完成整辆车的电气连接，做到安全，稳定,不影响机械结构的正常运动。 ==PS：注意电压转换模块的负载能力，有时挂载外设过多时，超出模块额定电流，会出现一些失常的现象== 杜邦线与杜邦线连接和杜邦线与电机端子焊接处必须使用电工胶带包裹 硬件连接参考 小车在电控方面可以分为主控，电源管理模块，底盘和云台模块。 主要电气连接原理图如上。 PS：请提前估计最小系统板上的资源和实际功能之间的关系，如果最小系统板 代码能力 外设驱动能力（底层） 可以驱动小车上所有所需外设，包括串口可以正常收发信息（UART串口通信）并且主控拥有接受遥控器信息处理（状态机）的能力，电机可以正常的进行开环控制（PWM控制）等； 驱动外设完成各种功能的能力 使用手机端蓝牙终端发送数据控制小车完成具体行动；通过控制底盘四个电机的转向和转速来控制小车整体的运动方向和速度；控制云台电机或者舵机完成取矿或者射击能力。 （这一部分建立在外设驱动的基础上，是电控的最终任务） 软件设计结构建议图 团队交流能力 作为一个队伍的成员，我们要和机械队员及时交流，互相沟通，了解小车的整体设计，了解机械结构具体需要电机怎么转才能达到机构的功能。 电控小车电控系统组成和思路分享（时间规划建议） 第一阶段（在机械队友出实物之前）推荐ddl:11月10日前 尽量完成所有所需外设的驱动，串口的接收，电机的驱动； 做好代码储备和基础代码框架的构建，为了机械完成实物组装后可以直接上手调； 第二阶段（机械队友出了实物就调）推荐ddl:这个看机械队友，但尽量11月末之前 机械队友出了实物就赶紧调，出什么调什么，底盘，云台哪个快调哪个； 这个阶段需要完成小车的部分功能，比如底盘运动，云台射击或者抓矿等宏观上的功能 第三阶段 完成整车的调试（优化阶段） 在这一阶段应该将整车调试完毕，小车可以完成计划中的大部分任务和功能 在这一阶段，你应该不断去优化小车的各种性能，包括控制是否灵敏，运动速度是否快，整个系统是否稳定等。 Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-24 18:22:49 "},"一些软件的使用/GIT简明教程.html":{"url":"一些软件的使用/GIT简明教程.html","title":"Git","keywords":"","body":"为什么要学习GIT Git，作为一款分布式版本控制系统（DVCS），其核心价值在于它能够详尽地存储并管理项目代码的每一次版本演变。这使得项目开发过程中的版本状态始终处于可控范围之内，为开发者提供了坚实的代码安全保障。具体而言： 版本回溯与问题修复： 当代码在某一修改后不幸引入了新的错误（BUG），我们可以通过Git强大的历史回溯能力，迅速定位并恢复到功能正常时的任一历史版本。这极大地降低了开发风险，确保了项目的快速故障恢复能力。 有序的版本进化： 通过遵循良好的提交（commits）规范，即在每次代码变更后清晰地记录修改内容和目的，我们可以构建起一个逻辑清晰、易于追踪的版本进化路径。这不仅有助于未来问题的诊断，更能规范化项目的长期迭代与演进。 同时，Git的另一大特色在于其卓越的团队协作能力。在现代软件开发，特别是像车载电控系统这样复杂的嵌入式项目中，代码工作往往不是由一个人单兵作战，而是由多名电控工程师（例如2-3人甚至更多）并行协作完成。在这种多方参与的模式下，传统的代码管理方式极易引发一系列挑战： 代码冲突难题： 当多位工程师不约而同地修改了同一处代码，并在尝试合并各自工作成果时，极易发生代码冲突。这会中断开发流程，需要耗费额外的时间和精力去协调和解决。 版本差异与历史保留： 随着项目进展，不同开发者的本地代码库版本可能出现显著差异。如何在不丢失任何一方修改历史记录的前提下，实现高效、有序且准确的代码合并，是另一个亟待解决的复杂问题。 Git针对这些痛点提供了成熟而高效的解决方案。它允许每位开发者基于主线代码（通常是称为main或master的分支）创建独立的开发分支（branch）。在个人分支上的所有修改，都只影响该分支，而不会直接干扰到其他分支或主线代码的稳定性。开发者可以在个人分支上自由开发、实验和测试，待功能完善并经过充分验证后，再将代码合并回主线。Git会在合并过程中自动进行冲突检测，并提供强大的工具协助解决这些冲突，从而有效地保障了团队协作的顺畅与代码集成的高效性。 在苍穹内部的Git使用 在苍穹内部的项目开发中，我们对Git的学习和掌握持务实高效的态度。我们的目标不要求成员全面精通Git的所有高级特性和复杂操作，而是强调其核心功能的应用，确保能够有效解决上文所提及的，关于代码版本控制和团队协作的关键问题。 为了在苍穹内部更好地利用Git，以下是一些基本的使用原则和工作流程建议： 理解分支策略： 掌握如何创建、切换和合并分支。通常我们会采用简洁的分支模型，例如main（或master）作为稳定发布分支，以及以个人名字命名的开发分支（例如zhang_san、li_si）来承载个人开发工作。每个个人分支承载了该开发者进行的各种功能开发或bug修复。 规范提交信息（Commit Messages）： 每一次提交都应包含清晰、简洁且有意义的提交信息。这不仅便于他人理解你的修改意图，也是未来追溯问题、理解代码演进的关键。建议遵循一定的提交信息格式（例如，包含类型、范围、描述等）。 频繁提交与同步： 鼓励开发者频繁地提交（git commit）个人工作进度，并定期将本地修改推送到远程仓库（git push），同时从远程拉取最新代码（git pull），保持与团队的同步。这有助于及时发现和解决潜在冲突，避免代码差异过大。 熟练掌握合并（Merge）与变基（Rebase）： 理解git merge和git rebase的区别和适用场景，特别是在保持提交历史整洁方面。在分支合并时，尤其是在将个人分支合并到main分支之前，应进行彻底的冲突检查和解决。善用图形化工具（如GitKraken、VS Code内置Git工具或Sourcetree）来辅助冲突解决。 代码审查（Code Review）： 将Git与代码审查流程相结合，通过Pull Request（或Merge Request）的机制，让团队成员对即将合并到主线的代码进行审查，确保代码质量、发现潜在问题并分享知识。 Git常用命令教程 为帮助大家快速掌握Git的实践操作，我们整理了一系列核心命令及其使用场景。你可以在Ubuntu 24.04的zsh终端中直接运行这些命令。 1. 初始化与克隆仓库 git init：在当前目录初始化一个新的Git仓库。当你有一个全新的项目，想要开始用Git管理时使用。# 进入你的项目目录 cd my_new_vehicle_project # 初始化Git仓库 git init git clone ：克隆一个远程Git仓库到本地。当你开始一个新项目或加入一个现有团队时，通常通过克隆远程仓库来获取所有代码和历史记录。# 克隆一个远程仓库到当前目录下的一个新文件夹 git clone https://gitserver.example.com/vehicle-software/ecu_firmware.git 2. 查看状态与添加文件 git status：查看工作区和暂存区的状态。这个命令会告诉你哪些文件被修改了、哪些文件已暂存、哪些是新文件但未被Git追踪。这是你最常用的命令之一，用来了解当前仓库的“健康状况”。 git status ``` 输出示例： On branch main Your branch is up to date with 'origin/main'. Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git restore ...\" to discard changes in working directory) modified: src/main.c Untracked files: (use \"git add ...\" to include in what will be committed) docs/requirements.txt `` 这表示src/main.c被修改但未暂存，docs/requirements.txt`是新文件未被追踪。 git add ：将文件添加到暂存区。暂存区是提交前的“缓冲区”。只有添加到暂存区的文件，才会被包含在下一次提交中。 # 添加单个文件到暂存区 git add src/main.c # 添加docs目录下的所有文件 git add docs/ # 添加所有修改过的或新创建的文件到暂存区 (慎用，确保你清楚添加了哪些文件) git add . 3. 提交更改 git commit -m \"Your commit message\"：将暂存区的更改提交到本地仓库。每次提交都是一次“快照”，代表了项目的一个稳定状态。-m参数后面是本次提交的简短描述信息，非常重要！# 提交所有暂存区的更改 git commit -m \"feat: 添加发动机转速控制逻辑\" 一个好的提交信息应该清晰说明： 类型： (feat: 新功能, fix: 修复bug, docs: 文档, style: 格式, chore: 构建/工具变更等) 描述： 详细说明本次提交做了什么。 4. 分支管理 git branch：列出所有本地分支。当前分支会有一个星号*标记。git branch git branch ：创建一个以你的名字命名的新分支。# 例如，你的名字是张三，创建一个名为zhang_san的分支 git branch zhang_san git checkout ：切换到指定分支。切换后，你的工作区会更新为该分支的代码版本。# 切换到zhang_san分支 git checkout zhang_san git checkout -b ：创建并立即切换到新分支。这是上面两个命令的快捷方式。# 创建并切换到li_si分支 git checkout -b li_si ```* **`git branch -d `**：**删除一个本地分支。**在合并了分支后，通常会删除不再需要的分支。 ```zsh # 删除名为zhang_san的分支 (前提是该分支已合并到其他分支) git branch -d zhang_san # 如果分支未合并，但确定要删除，可以使用 -D 强制删除 # git branch -D zhang_san 5. 远程操作 git remote -v：查看已配置的远程仓库。通常你会看到origin，它指向你的主远程仓库。 git remote -v 输出示例可能如下： origin https://gitserver.example.com/vehicle-software/ecu_firmware.git (fetch) origin https://gitserver.example.com/vehicle-software/ecu_firmware.git (push) git push origin ：将本地分支的提交推送到远程仓库。这是与团队成员分享你的代码变更的方式。 # 将当前本地分支的更改推送到远程同名分支 git push origin zhang_san # 首次推送新分支时，可能需要设置上游分支，方便后续直接git push git push -u origin zhang_san git pull origin ：从远程仓库拉取（获取并合并）最新代码。在开始工作前或定期拉取，以确保你的本地仓库与远程仓库保持同步。 # 拉取远程main分支的最新代码并合并到当前本地分支 (例如，当你在zhang_san分支工作，需要获取main的更新) git pull origin main 修改 origin 远程仓库的 URL 有时候，远程仓库的地址会发生变化（例如，项目迁移到新的Git服务器，或者URL拼写错误）。这时，你需要更新本地仓库中 origin 对应的URL。 git remote set-url origin ：更新名为 origin 的远程仓库的URL。 操作步骤： 首先，查看当前的 origin URL，确认其旧地址。git remote -v 使用 set-url 命令修改 origin 的URL。 将 https://new-gitserver.example.com/vehicle-software/ecu_firmware.git 替换为你的新远程仓库地址。git remote set-url origin https://new-gitserver.example.com/vehicle-software/ecu_firmware.git 再次查看 origin URL，确认修改已生效。git remote -v 输出应该显示新的URL：origin https://new-gitserver.example.com/vehicle-software/ecu_firmware.git (fetch) origin https://new-gitserver.example.com/vehicle-software/ecu_firmware.git (push) 现在，你所有的 git push 和 git pull 操作都会指向新的远程仓库地址了。 6. 合并分支 git merge ：将指定分支的更改合并到当前所在分支。# 假设你当前在main分支（已通过git checkout main切换），你想把zhang_san分支的更改合并进来 git checkout main git merge zhang_san 如果发生冲突，Git会提示你手动解决冲突。解决后，需要git add冲突文件，然后git commit完成合并。 7. 更新个人分支（Rebase） 在开发过程中，main分支可能会有新的提交。为了让你的个人工作分支（如zhang_san）保持最新，并且拥有更线性、整洁的提交历史，我们可以使用 git rebase。 git rebase ：将当前分支的更改“变基”到指定的基础分支上。 这会将你的个人分支上的所有提交“剪切”下来，然后将它们重新“粘贴”到base_branch的最新提交之后。结果是，你的个人分支历史看起来就像是从base_branch的最新点开始的，没有分叉合并的痕迹，历史更清晰。 使用场景： 当你在zhang_san分支上工作时，main分支有了新的更新，你想把这些更新整合到你的zhang_san分支，并且希望保持提交历史的简洁线性。 操作步骤： 保存你当前分支的本地修改（如果有的话）。确保工作区干净，或者先git add .和git commit。git status # 确认工作区干净 切换到你的个人分支（例如zhang_san）。git checkout zhang_san 拉取远程 main 分支的最新代码，确保本地的 main 分支是最新的。git pull origin main:main # 拉取origin/main到本地main分支 或者先切换到 main，拉取，再切换回你的分支：git checkout main git pull origin main git checkout zhang_san 执行 rebase 操作，将 zhang_san 分支变基到 main 分支上。git rebase main 此时，Git会将zhang_san分支上的所有提交逐个应用到main分支的最新状态之上。 解决可能发生的冲突：如果zhang_san分支的修改与main分支的更新有冲突，Git会在每个冲突点暂停，你需要手动解决。 编辑冲突文件，解决冲突。 git add git rebase --continue (继续rebase过程) 如果需要中止rebase，可以使用 git rebase --abort。 Rebase完成后，如果之前曾将此分支推送到远程（git push origin zhang_san），那么你现在需要强制推送，因为rebase改变了分支历史。请务必小心强制推送，只在你确信当前分支不是共享分支，或已与团队成员沟通好时才使用。git push --force-with-lease origin zhang_san --force-with-lease 相比 --force 更安全，它会检查远程分支在你上次拉取后是否被其他人更新过，避免覆盖他人的工作。 何时慎用或避免 rebase： 不要对已经推送到远程的、且有其他人在其之上工作的共享分支执行 rebase。 rebase 会改写历史，强行推送会给团队成员带来回滚和同步的巨大麻烦。个人开发分支在未合并到main并通过Code Review之前，通常是安全的。 8. 查看历史记录 git log：查看提交历史。按时间顺序显示所有提交记录，包括提交者、日期、提交信息等。git log # 以更简洁的单行格式显示，配合图形化工具理解分支走向 git log --oneline --graph --decorate 通过有效掌握和实践这些Git命令，苍穹的团队成员将能够更高效、更协作地进行代码开发，保障车载电控项目的质量和进度。记住，熟能生巧，多使用、多练习是掌握Git的关键。遇到问题时，不要犹豫查阅Git官方文档或向团队中的Git专家寻求帮助。 Copyright © RM苍穹战队 all right reserved，powered by Gitbook该文件修订时间： 2025-10-10 20:21:55 "}}
# 我们如何通过代码控制单片机

## 单片机：一个功能强大的机器人

想象一下，你买来一个非常强大的机器人（这就是**单片机**，Microcontroller Unit, MCU）。这个机器人身体上集成了很多设备，比如：

* 它的手臂和腿脚（**GPIO引脚**，可以输出高低电平来控制LED灯亮灭或检测按键）。
* 它内置的多个闹钟和秒表（**定时器/计数器**）。
* 它的“耳朵”和“嘴巴”，可以用来和别的设备沟通（**串行通信接口**，如UART, SPI, I2C）。

但是，这个机器人出厂时只会“待机”，你无法直接用语音命令它。你需要一本详细的《机器人控制手册》和一种特殊的“编程语言”来给它下达指令。

## 寄存器：机器人的“控制面板”

这本《机器人控制手册》（也就是单片机的**数据手册 DataSheet**）告诉你，机器人的所有功能都是通过它胸前一个巨大、精密、布满了开关和指示灯的**控制面板**来操作的。

这个控制面板就是**寄存器（Register）**。

<figure><img src="../.gitbook/assets/image (28).png" alt=""><figcaption></figcaption></figure>

* **每一个开关/旋钮**都对应机器人身体的一个具体功能。比如，A区的1号开关，拨到“开”，机器人左手的LED灯就会亮；拨到“关”，灯就灭。
* **每一个指示灯**则会显示机器人当前的状态。比如，B区的3号指示灯亮了，表示它的“耳朵”（UART接口）听到了外部传来的信息。

这些“开关”和“指示灯”在单片机内部，其实就是一个个极小的、有特定地址的内存单元。它们由成千上万的“0”和“1”组成（二进制位）。

## 软件/代码：你的“遥控指令”

现在，你作为“程序员”，要做的事情就是编写一段指令代码（通常使用C语言），告诉单片机如何去操作那个“控制面板”（寄存器）。

这个过程分为几步：

1. **查阅手册（阅读DataSheet）**： 你想让机器人左臂上的灯闪烁。你翻开手册，在“GPIO”章节找到了说明：“要控制左臂的灯，你需要操作地址编号为 `0x4001080C` 的那个控制面板（这是一个寄存器的地址）。将这个面板上的第5个开关拨到‘开’（写入‘1’），灯就会亮；拨到‘关’（写入‘0’），灯就会灭。”
2.  **编写指令（写C代码）**： 你不能真的伸手去拨开关，但你可以通过C语言代码来做到这一点。在C语言中，你可以像操作一个普通变量一样，去操作那个特定地址的“控制面板”。

```
// 这是一个“宏定义”，给那个难记的地址起个好记的名字
#define GPIOA_ODR *(volatile unsigned int*)0x4001080C  
   //上面引脚定义地址是库函数帮助开发者做的事情

// 主程序开始
void main() {
    // 指令1：将第5个开关拨到“开” (通过位运算实现)
    GPIOA_ODR |= (1 << 5);  // 灯亮

    // (延时一会儿)

    // 指令2：将第5个开关拨到“关”
    GPIOA_ODR &= ~(1 << 5); // 灯灭
}
```

-   `*(volatile unsigned int*)0x4001080C` 这段代码就像是你的“魔法手指”，它告诉编译器：“请直接访问物理地址是 `0x4001080C` 的那个地方，把它当成一个整数来操作。”
-   `|= (1 << 5)` 是一个位操作，它精准地将这个“整数”的第5位（对应第5个开关）设置为1，同时不影响其他位（其他开关）。

3. **编译和烧录（发送指令给机器人）**： 你写的C代码，通过**编译器**翻译成机器人唯一能懂的机器语言（一堆0和1）。然后，通过**烧录器**，将这些机器指令传送到机器人的“大脑”里（单片机的Flash存储器）。
4. **运行（机器人执行指令）**： 机器人上电后，它的CPU会一条一条地执行你烧录进去的指令。当它执行到 `GPIOA_ODR |= (1 << 5);` 这条时，CPU内部的控制单元就会真的去物理地址 `0x4001080C` 处，把第5位置为1。瞬间，连接在GPIO引脚上的LED灯就被点亮了。
